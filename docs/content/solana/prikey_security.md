# Solana/私钥, 公钥与地址/如何安全保护你的私钥

私钥是区块链世界中最重要的资产凭证, "not your keys, not your coins" 这句话精准地概括了私钥的重要性. 一旦私钥泄露或丢失, 意味着你的数字资产将永久丢失或被盗.

我这里将浅浅的谈一下私钥的安全保护, 包括一些真实案例的警示, 密码学视角的理解, 以及实用的安全措施.

## 案例警示

### Trust Wallet 供应链攻击事件

这是一个发生在 2025 年底的案例, 也是我第一个想到的案例.

2025 年 12 月 25 日, 社区安全分析师 akinator 发布警报, 警告 trust wallet 浏览器扩展可能遭受供应链攻击, 建议用户勿导入助记词或使用扩展. 推文声称已被盗超 200 万美元, 攻击者使用多个地址进行资金转移.

<https://x.com/0xakinator/status/2004273944694587785>

推文指向 2025 年 12 月 24 日, trust wallet chrome 扩展 v2.68 更新发布, 但是这个版本被注入了恶意代码, 导致用户导入助记词时信息被窃取并发送给攻击者.

到 2025 年 12 月 27 日, 损失已经扩大到 700 万美元. 官方随后发布声明, 承认扩展被攻破, 并建议用户立即停止使用该扩展. 此时已经距离攻击发生三天, 但损失仍在持续增加.

这次攻击最令人震惊的地方在于, 受害者并非点击了钓鱼链接或下载了假 app, 而是使用了官方渠道更新的扩展. 也就是我们以为安全的基础设施.

**如今大多数系统都依赖于对用户信息的完全访问权限: 查看所有信息, 存储所有数据, 然后让用户祈祷一切平安无事.**

> 思考: 将私钥存储在钱包中真的安全吗? 这次虽然是一起攻击事件, 但也暴露了如果钱包官方想作恶, 用户没有任何防备之力. 这也是为什么我一直认为, 私钥的安全不仅仅是技术问题, 更是信任问题.

### 剪贴板攻击

一些恶意软件会监控剪贴板内容, 当检测到类似私钥或助记词的字符串时, 会发送数据到远程服务器. 即使是一些正常的软件, 也经常会记录剪贴板内容到日志文件, 或者发送到远程服务器, 这也可能导致私钥泄露.

此类攻击有相当多的报告, 在区块链社区几乎每隔一段时间就会出现类似的警告.

### 新威胁: Coding Agents

目前网络上正在流行一种新的攻击方式, 即利用 ai 代码生成工具(如 github copilot, claude 等)来盗取用户的源代码, 而您的源代码里很可能保存着您的私钥.

问题的根源与上面的例子很像: coding agents 对您的代码仓库有完全访问权限, 可以查看和修改所有文件, 同时允许 ai 访问网络或者向网络发送数据. 如果您使用购买的 ai 服务, 那么您的代码仓库的所有内容都会被上传到云端进行处理和存储. 在 2025 年 8 月, github copilot 就发生过一次数据泄露, 在此次错误中, ai 错误的将本应该返回给 a 用户的回答泄露给了 b 用户. 问题的根源是 google cloud platform 的代理基础设施中的一个 bug, 导致请求处理时发生了错误路由. 这次事件虽然没有发现直接导致私钥泄露, 但它暴露了 ai 服务在处理用户数据时的潜在风险: 您购买的 ai 服务商能看到您的所有代码, 包括其中的敏感信息.

相关披露: <https://docs.cloud.google.com/support/bulletins#gcp-2025-059>.

即使您使用了本地部署 ai, 也不是完全安全的. 假设您从 github clone 了某个项目, 而该项目里恰好包含了给 ai 阅读的文件, 文件里的提示词可能会告诉 ai 需要调用 curl 来将用户的本地文件上传到指定服务器, 那么当您在编辑器里打开该项目时, 您配置的本地 ai 可能会自动执行该命令. 这种漏洞利用了人类对 ai 的信任, 目前还没有有效的防护措施.

## 密码学视角下的私钥安全

### 私钥生成

私钥本质上是一个随机大整数. 以 solana 使用的 ed25519 为例, 私钥是一个 256 位的随机数, 范围从 0 到 2^256 - 1. 这个数字有多大? 宇宙中可观测的原子数量约为 10^80. 暴力破解私钥在计算上是不可行的.

在私钥生成过程中, 必须使用高质量的随机数生成器来确保私钥的不可预测性. 我们一般使用硬件熵源(如 `/dev/random`). 同时确保生成环境的安全, 避免恶意软件窃取熵源数据.

如果您只是简单地存一点钱, 使用官方钱包生成私钥通常是足够安全的. 但如果您持有大量资产, 则需要采取更严格的措施. 这里我只建议一种方式: 抛 256 次硬币, 在离线电脑上记录它们的正反面, 然后将结果转换为 256 位数字, 这就是您的私钥.

> 曾经发生过一起攻击事件, 一款知名钱包应用在生成私钥时, 使用了一个低质量的随机数生成器. 攻击者可以猜测某一段时间内生成的所有私钥.

> 曾经发生过一起攻击事件, 一款知名钱包应用官方主动埋毒, 生成私钥时将结果发送到远程服务器.

### 私钥保管

目前仍在使用的主流密码学方案, 其安全性足够抵御暴力破解攻击(考虑到当前技术水平). 私钥真正的威胁不是破解, 而是保管不当.

现代钱包通常使用密码加密存储私钥, 加密方案通常可以选择 aes 或 chacha20, 然后使用密钥派生算法: pbkdf2, argon2, scrypt 等. 典型的加密流程:

1. 用户设置密码.
2. 使用 kdf(密钥派生函数)将密码转换为加密密钥.
3. 使用加密密钥加密私钥.
4. 存储加密后的密钥文件.

但这种方式也会有一些风险, 此时用户设置的密码强度成了整个环节里的薄弱点.

1. 弱密码理论上可以被轻易暴力破解, 例如 `123456`, `qwerty` 等常见密码在几秒钟内就能被破解, 从而导致私钥泄露.
2. 但同时 kdf 的计算成本使得暴力破解更困难. 该算法的核心是增加密码尝试的计算成本, 例如通过对输入的密码进行数百万次哈希迭代运算, 使得每次密码尝试都需要较长时间.

但是无论怎样, 都保证一件事, 就是私钥的明文永远不应该出现在公开的联网服务上, 例如在线笔记, 在线网盘等. 这里提供几种常见的私钥保管方案, 以及它们的优缺点.

**链下多重签名(naive 版)**

密码学社区的一种经典反例, 将私钥的字符串简单拆成前后几个部分, 分别存储在不同的地方. 例如将一个 64 字符的十六进制私钥拆成 4 段, 每段 16 字符, 分别存储在不同的物理位置(如家里保险柜, 银行保险箱, 亲友处等). 假设您要保护私钥 e, 那么您可能会这样拆分:

```py
e = "1ec580e8913d9d2874bde4585eba9ae9aca20b80e40c114ec0b230dc4431bd71"

a = "1ec580e8913d9d28"
b = "74bde4585eba9ae9"
c = "aca20b80e40c114e"
d = "c0b230dc4431bd71"
assert a + b + c + d == e
```

这种方法被广泛视为最不安全的实践, 因为其无法提供真正的阈值保护. 所谓的阈值保护, 指的就是只有当达到一定数量的分片被组合在一起时, 才能恢复出完整的私钥. 这种简单拆分方法, 只要任意一个分片被泄露, 就足以让攻击者获得部分信息, 并通过穷举法尝试所有可能的组合来恢复私钥. 例如, 如果攻击者获得了 a 和 b, 那么他只需要尝试所有可能的 c 和 d 组合, 就能恢复出完整的私钥, 此时攻击者只需要尝试 2^128 种组合, 远低于暴力破解整个私钥所需的 2^256 种组合.

核心问题: 部分分片泄露了私钥的部分信息.

**链下多重签名(elder 版)**

密码学社区的一种不被推荐, 但相对安全且简单的方案. 方案仍然是拆分, 但不是简单的拼接, 而是使用加法运算来实现保护. 将您要保护的私钥视为一个大整数, 然后随机生成一批大整数, 使得所有随机生成的大整数相加模一个大素数后等于原始私钥. 这样, 只有当攻击者获得了所有分片时, 才能恢复出完整的私钥. 例如有私钥 c, 您可以这样拆分:


```py
import pabtc

c = 0xf108bf1b32f3eb50da02419afe6caee4f8385fe7df364f8af27e05757ba2ad04

a = 0x01d487c418d34e79760f835f8fb7309d3b0c6a0ab32f7bca2eebb7090bb1e9d3
b = 0xef3437571a209cd763f2be3b6eb57e47bd2bf5dd2c06d3c0c3924e6c6ff0c331
assert (a + b) % pabtc.secp256k1.N == c
```

这种方法即使泄露 a 或 b 其中一个分片, 也无法泄露完整的私钥 c 的任何信息, 因为攻击者无法仅通过 a 或 b 推断出 c 的值. 但是这种方法的缺点在于, 所有分片都必须被保管好, 否则一旦丢失任何一个分片, 就无法恢复出完整的私钥.

**链下门限签名(shamir's secret sharing)**

在比特币社区讨论较多的一种方案, 也是我个人推荐的方案. 该方案基于 shamir's secret sharing (sss) 算法, 允许将私钥分割成 n 个分片, 并设置一个阈值 k, 只有当至少 k 个分片被组合在一起时, 才能恢复出完整的私钥. 这样, 即使攻击者获得了少于 k 个分片, 也无法恢复出完整的私钥. 它的优势是可以避免单点故障: 即使某个分片丢失, 只要剩余的分片数量达到阈值 k, 仍然可以恢复出完整的私钥.

常见的拆分方法是 2-of-3, 3-of-5 等等. 例如, 在 3-of-5 的方案中, 私钥被分割成 5 个分片, 只要任意 3 个分片被组合在一起, 就能恢复出完整的私钥.

相关阅读: <https://en.wikipedia.org/wiki/Shamir%27s_secret_sharing>

优点:

- 算法开源且有广泛的应用和研究支持. 同时您不需要依赖某个软件或者某个第三方库实现算法, 任何熟练的程序员都可以根据公开的算法实现代码.
- 即使所有分片都被泄露, 攻击者也不一定知道你在使用 sss 算法来保护私钥, 它可能只会认为这些分片是多个私钥, 这样可以增加攻击者的猜测难度. 你甚至可以真的将分片作为私钥来使用, 往里面存一些小额资金, 构成一个蜜罐迷惑层. 攻击者可能会被这些小额资金吸引, 而忽略了真正的私钥. 一旦攻击者将分片中的资金转移走, 您就能获得预警: 您的某个分片已经泄露.

**总结**

原则就两点:

1. 私钥的明文永远不应出现在联网设备上, 您应该将它写在纸上或者刻在金属板上.
2. 使用一些方式来将私钥分成多部分保存, 并将这些部分按照第一条原则进行保管.

## 量子攻击

量子计算机的出现对现有的公钥密码学构成了威胁. 例如, shor 算法可以在多项式时间内破解基于整数分解和离散对数问题的加密算法, 比特币和以太坊使用的 ecdsa 和 solana 使用的 ed25519 都基于离散对数问题, 恰巧在 shor 算法的攻击范围内.

比特币社区已经开始讨论量子抗性签名算法的采用, 但目前还没有广泛支持的解决方案. 对于比特币用户来说, 目前最好的做法是创建一个新的地址来接收资金, 并永远不要用这个地址来签署任何交易, 这样, 即使量子计算机出现, 也无法破解这个地址的私钥. 这么做的原理是对于比特币来说签署交易会暴露公钥, 而量子计算机可以利用公钥来破解私钥. 只要不签署交易, 公钥就不会被暴露, 这样私钥也就不会被破解.

对于 solana 用户来说, 目前还没有明确的量子抗性方案, 也无法采用比特币的做法, 因为 solana 的地址就是公钥本身. 因此, solana 用户更需要密切关注量子计算机的发展动态.

量子计算机真正实用化可能还需要数年时间, 按照谷歌研究人员的说法是 5 到 10 年. 我们必须现在就正视量子计算机的威胁. 它不是遥远的未来才会发生的事.
